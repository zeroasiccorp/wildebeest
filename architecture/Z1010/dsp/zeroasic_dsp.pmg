// ISC License
// 
// Copyright (C) 2025  Frederick Tombs <fred@zeroasic.com>, Zero Asic Corp.
// Copyright (C) 2024 Microchip Technology Inc. and its subsidiaries
// 
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

pattern zeroasic_dsp_pack

state <SigBit> clock
// A, B: * inputs. C: 3rd input (to adder). D: input to adder (could be same as C)
state <SigSpec> sigA sigB sigC sigD sigP sigMultOut
state <Cell*> ffA ffB ffC ffP
state <Cell*> postAdderStatic
state <bool> useFeedBack multHasReg

// static ports, used to detect dsp configuration
state <SigSpec> bypassA bypassB bypassC bypassP

// Variables used for subpatterns
state <SigSpec> argQ argD
udata <bool> allowAsync
udata <SigSpec> dffD dffQ
udata <SigBit> dffclock
udata <Cell*> dff
udata <Cell*> u_postAdderStatic
udata <IdString> u_postAddAB
state <IdString> postAddAB

// Identify MAE
match dsp
	select dsp->type.in(\MAE)
endmatch

// detect existing signals connected to DSP
// detect configuration ports
code sigA sigB sigC sigD clock sigP sigMultOut
	//helper function to remove unused bits
	auto unextend = [](const SigSpec &sig) {
		int i;
		for (i = GetSize(sig)-1; i > 0; i--)
			if (sig[i] != sig[i-1])
				break;
		// Do not remove non-const sign bit
		if (sig[i].wire)
			++i;
		return sig.extract(0, i);
	};

	//unextend to remove unused bits
	sigA = unextend(port(dsp, \A));
	sigB = unextend(port(dsp, \B));

	//update signals
	sigC = port(dsp, \C, SigSpec());


	SigSpec P = port(dsp, \P);
	// Only care about bits that are used
	int i;
	for (i = GetSize(P)-1; i >= 0; i--)
		if (nusers(P[i]) > 1)
			break;
	i++;
	log_assert(nusers(P.extract_end(i)) <= 1);
	// This sigP could have no users if downstream sinks (e.g. $add) is
	//   narrower than $mul result, for example
	if (i == 0)
		reject;
	sigP = P.extract(0, i);
	clock = port(dsp, \CLK, SigBit());

endcode

// detect if multiplier output is registered (useful for discerning macc vs macc_pipe)
code argD sigMultOut multHasReg
	sigMultOut = sigP; // sigP moves around, we want to keep track of multiplier output.
	if (nusers(sigP) == 2) {
		argD = sigMultOut;
		allowAsync = false;
		subpattern(out_dffe);
		if (dff) {
			multHasReg = true;
		}
	}

endcode

// capture static configuration ports
code bypassA bypassB bypassC bypassP
	bypassA = port(dsp, \A_BYPASS, SigSpec());
	bypassB = port(dsp, \B_BYPASS, SigSpec());
	bypassC = port(dsp, \C_BYPASS, SigSpec());
	bypassP = port(dsp, \P_BYPASS, SigSpec());
endcode

//  post adder
// sigD will be aborbed.
code postAdderStatic sigP sigD
	u_postAdderStatic = nullptr;
	subpattern(postAddMatching);
	postAdderStatic = u_postAdderStatic;

	if (postAdderStatic) {
		//sigD will be whichever input to the postAdder that is NOT from the multiplier
		// u_postAddAB is the input to the postAdder from the multiplier
		sigD = port(postAdderStatic, u_postAddAB == \A ? \B : \A);
		sigP = port(postAdderStatic, \Y);
	}
endcode


// REG_A, B, P
//
// 'A' input for REG_A
code argQ bypassA sigA clock ffA
	if (bypassA.is_fully_ones()){
		argQ = sigA;
		allowAsync = false;
		subpattern(in_dffe);
		if (dff) {
			ffA = dff;
			clock = dffclock;
			sigA = dffD;
		}
	}
endcode

// 'B' input for REG_B
code argQ bypassB sigB clock ffB
	if (bypassB.is_fully_ones()){
		argQ = sigB;
		allowAsync = false;
		subpattern(in_dffe);
		if (dff) {
			ffB = dff;
			clock = dffclock;
			sigB = dffD;
		}
	}
endcode



// 'P' output for REG_P
code argD ffP sigP clock bypassP
	if (bypassP.is_fully_ones() && nusers(sigP) == 2) {
		argD = sigP;
		allowAsync = false;
		subpattern(out_dffe);
		if (dff) {
			ffP = dff;
			clock = dffclock;
			sigP = dffQ;
		}
	}

endcode

// Detect if registered output of post-adder feeds back into post-adder (feedback)
code useFeedBack
	useFeedBack = false;
	if (postAdderStatic)	{
		if (sigD == sigP) {
			useFeedBack = true;
		}
	}
endcode

// 'C' input for REG_C
code argQ sigC clock ffC
	if (bypassC.is_fully_ones() and not useFeedBack){
		argQ = sigC;
		allowAsync = true;
		subpattern(in_dffe);
		if (dff) {
			ffC = dff;
			clock = dffclock;
			sigC = dffD;
		}
	}
endcode

// if any cells are absorbed, invoke the callback function
code
	if (postAdderStatic)
		accept;
	if (ffA || ffB || ffC || ffP) {
		accept;
	}
endcode

// #######################
// Subpattern for matching against post-adder
//   Match 'P' output that exclusively drives one of two inputs to an $add
//   cell (post-adder).
//   The other input to the adder is assumed to come in from the 'C' input

subpattern postAddMatching
arg sigP

match postAdd

	select postAdd->type.in($add)
	select GetSize(port(postAdd, \Y)) <= 40

	// AB is the port that connects MUL to ADD
	choice <IdString> AB {\A, \B}

	select nusers(port(postAdd, AB)) == 2

	set postAddAB AB
	// optional
endmatch

code
	if (postAdd)
	{
		u_postAddAB = postAddAB;
		u_postAdderStatic = postAdd;

	}
endcode


// #######################
// Subpattern for matching against input registers, based on knowledge of the
//   'Q' input.
subpattern in_dffe
arg argQ clock

code
	dff = nullptr;
	if (argQ.empty())
		reject;
	for (const auto &c : argQ.chunks()) {
		// Abandon matches when 'Q' is a constant
		if (!c.wire)
			reject;
		// Abandon matches when 'Q' has the keep attribute set
		if (c.wire->get_bool_attribute(\keep))
			reject;
		// Abandon matches when 'Q' has a non-zero init attribute set
		Const init = c.wire->attributes.at(\init, Const());
		if (!init.empty())
			for (auto b : init.extract(c.offset, c.width))
				if (b != State::Sx && b != State::S0)
					reject;
	}
endcode

match ff
	// reg D has async rst
	// reg A, B has sync rst
	select ff->type.in($dff, $dffe, $sdff, $sdffe, $adff, $adffe, $dffr)
	// does not support clock inversion
	select param(ff, \CLK_POLARITY).as_bool()

	// it is possible that only part of a dff output matches argQ
	slice offset GetSize(port(ff, \D))
	index <SigBit> port(ff, \Q)[offset] === argQ[0]

	// Check that the rest of argQ is present
	filter GetSize(port(ff, \Q)) >= offset + GetSize(argQ)
	filter port(ff, \Q).extract(offset, GetSize(argQ)) == argQ

	// clock must be consistent
	filter clock == SigBit() || port(ff, \CLK)[0] == clock
endmatch

code argQ
	// Check that reset value, if present, is fully 0.
	bool noResetFlop = ff->type.in($dff, $dffe);
	bool srstZero = ff->type.in($sdff, $sdffe) && param(ff, \SRST_VALUE).is_fully_zero();
	bool arstZero = ff->type.in($adff, $adffe) && param(ff, \ARST_VALUE).is_fully_zero();
	bool resetLegal = noResetFlop || srstZero || arstZero;
	if (resetLegal)
	{
		SigSpec Q = port(ff, \Q);
		dff = ff;
		dffclock = port(ff, \CLK);
		dffD = argQ;
		SigSpec D = port(ff, \D);
		argQ = Q;
		dffD.replace(argQ, D);
	}

endcode


subpattern out_dffe
arg argD argQ clock

code
	dff = nullptr;
	for (auto c : argD.chunks())
		// Abandon matches when 'D' has the keep attribute set
		if (c.wire->get_bool_attribute(\keep))
			reject;
endcode

match ff
	select ff->type.in($dff, $dffe, $sdff, $sdffe, $adff, $adffe, $dffr)
	// does not support clock inversion
	select param(ff, \CLK_POLARITY).as_bool()

	slice offset GetSize(port(ff, \D))
	index <SigBit> port(ff, \D)[offset] === argD[0]

	// Check that the rest of argD is present
	filter GetSize(port(ff, \D)) >= offset + GetSize(argD)
	filter port(ff, \D).extract(offset, GetSize(argD)) == argD

	filter clock == SigBit() || port(ff, \CLK)[0] == clock
endmatch

code argQ
	SigSpec D = port(ff, \D);
	SigSpec Q = port(ff, \Q);
	argQ = argD;
	argQ.replace(D, Q);

	// Abandon matches when 'Q' has a non-zero init attribute set
	for (auto c : argQ.chunks()) {
		Const init = c.wire->attributes.at(\init, Const());
		if (!init.empty())
			for (auto b : init.extract(c.offset, c.width))
				if (b != State::Sx && b != State::S0)
					reject;
	}

	dff = ff;
	dffQ = argQ;
	dffclock = port(ff, \CLK);
endcode
