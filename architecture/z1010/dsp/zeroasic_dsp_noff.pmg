// ISC License
// 
// Copyright (C) 2024 Microchip Technology Inc. and its subsidiaries
// 
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


// This file describes the main pattern matcher setup (of three total) that
//   forms the `zeroasic_dsp_noff` pass described in zeroasic_dsp_noff.cc 
// At a high level, it works as follows:
//   ( 1) Starting from a DSP cell. Capture DSP configurations as states
//   ( 2) Match for pre-adder
//   ( 3) Match for post-adder
//   ( 4) Match register 'A', 'B', 'D', 'P' 
//   ( 5) If post-adder and PREG both present, check if PREG feeds into post-adder.
//        This indicates an accumulator situation like the ASCII diagram below:
//             +--------------------------------+
//             |_________                       |
//                       | /-------\   +----+   |
//            +----+     +-| post- |___|PREG|---+ 'P'
//            |MULT|------ | adder |   +----+
//            +----+       \-------/

pattern zeroasic_dsp_noff_pack

state <SigBit> clock
state <SigSpec> sigA sigB sigC sigD sigP
state <Cell*> ffA ffB ffD ffP
state <Cell*> preAdderStatic postAdderStatic
state <bool> moveBtoA useFeedBack

// static ports, used to detect dsp configuration
state <SigSpec> bypassA bypassB bypassC bypassD bypassP
state <SigSpec> bypassPASUB

// Variables used for subpatterns
state <SigSpec> argQ argD
udata <bool> allowAsync
udata <SigSpec> dffD dffQ
udata <SigBit> dffclock
udata <Cell*> dff
udata <Cell*> u_preAdderStatic u_postAdderStatic
udata <IdString> u_postAddAB
state <IdString> postAddAB

// (1) Starting from a DSP cell
match dsp
	select dsp->type.in(\MACC_PA)
endmatch

// detect existing signals connected to DSP
// detect configuration ports
code sigA sigB sigC sigD clock sigP
	//helper function to remove unused bits
	auto unextend = [](const SigSpec &sig) {
		int i;
		for (i = GetSize(sig)-1; i > 0; i--)
			if (sig[i] != sig[i-1])
				break;
		// Do not remove non-const sign bit
		if (sig[i].wire)
			++i;
		return sig.extract(0, i);
	};

	//unextend to remove unused bits
	sigA = unextend(port(dsp, \A));
	sigB = unextend(port(dsp, \B));

	//update signals
	sigC = port(dsp, \C, SigSpec());
	sigD = port(dsp, \D, SigSpec());


	SigSpec P = port(dsp, \P);
	// Only care about bits that are used
	int i;
	for (i = GetSize(P)-1; i >= 0; i--)
		if (nusers(P[i]) > 1)
			break;
	i++;
	log_assert(nusers(P.extract_end(i)) <= 1);
	// This sigP could have no users if downstream sinks (e.g. $add) is
	//   narrower than $mul result, for example
	if (i == 0)
		reject;
	sigP = P.extract(0, i);
	clock = port(dsp, \CLK, SigBit());

endcode

// capture static configuration ports
code bypassA bypassB bypassC bypassD bypassPASUB bypassP
	bypassA = port(dsp, \A_BYPASS, SigSpec());
	bypassB = port(dsp, \B_BYPASS, SigSpec());
	bypassC = port(dsp, \C_BYPASS, SigSpec());
	bypassD = port(dsp, \D_BYPASS, SigSpec());
	bypassPASUB = port(dsp, \PASUB_BYPASS, SigSpec());
	bypassP = port(dsp, \P_BYPASS, SigSpec());
endcode

//  (3) Match for post-adder
//
code postAdderStatic sigP sigC
	u_postAdderStatic = nullptr;
	subpattern(postAddMatching);
	postAdderStatic = u_postAdderStatic;

	if (postAdderStatic) {
		//sigC will be whichever input to the postAdder that is NOT from the multiplier
		// u_postAddAB is the input to the postAdder from the multiplier 
		sigC = port(postAdderStatic, u_postAddAB == \A ? \B : \A);
		sigP = port(postAdderStatic, \Y);
	}
endcode


// if any cells are absorbed, invoke the callback function
code
	if (postAdderStatic)
		accept;
endcode


// #######################
// Subpattern for matching against post-adder
//   Match 'P' output that exclusively drives one of two inputs to an $add
//   cell (post-adder).
//   The other input to the adder is assumed to come in from the 'C' input

subpattern postAddMatching
arg sigP

match postAdd

	select postAdd->type.in($add, $sub)
	select GetSize(port(postAdd, \Y)) <= 48

	// AB is the port that connects MUL to ADD
	choice <IdString> AB {\A, \B}
	select nusers(port(postAdd, AB)) == 2

	// has one input coming from multiplier
	index <SigBit> port(postAdd, AB)[0] === sigP[0]
	filter GetSize(port(postAdd, AB)) >= GetSize(sigP)
	filter port(postAdd, AB).extract(0, GetSize(sigP)) == sigP
	// Check that remainder of AB is a sign- or zero-extension
	filter port(postAdd, AB).extract_end(GetSize(sigP)) == SigSpec(sigP[GetSize(sigP)-1], GetSize(port(postAdd, AB))-GetSize(sigP)) || port(postAdd, AB).extract_end(GetSize(sigP)) == SigSpec(State::S0, GetSize(port(postAdd, AB))-GetSize(sigP))

	set postAddAB AB
	// optional
endmatch

code
	if (postAdd)
	{
		if (postAdd->type.in(ID($sub)) && postAddAB == \A) {
			// if $sub, the multiplier output must match to $sub.B, otherwise no match	
		} else {
			u_postAddAB = postAddAB;
			u_postAdderStatic = postAdd;
		}

	}
endcode

